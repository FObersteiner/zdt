# -*- coding: utf-8 -*-
import random
from pathlib import Path
from datetime import datetime, timezone

random.seed(487)

dst = (Path(__file__).parent / ".." / "tests" / "test_datetime.zig").resolve()
search = "// the following test is auto-generated by gen_test_dt-from-unix.py. do not edit this line and below.\n"

with open(dst, "r") as fobj:
    content = fobj.readlines()

idx = content.index(search)
assert idx > 0

content = content[: idx + 1]
content.append("\n")

OPEN_BRACE = "{"
CLOSE_BRACE = "}"

# --- seconds, use full range ---

# UNIX_s_MIN = -62_135_596_800
# UNIX_s_MAX = 253_402_300_799

# print('test "unix seconds, fields" {')
# for s in random.sample(range(UNIX_s_MIN, UNIX_s_MAX + 1), 100):
#     dt = datetime.fromtimestamp(s, tz=timezone.utc)
#     print(
#         f"""  // {dt.isoformat()} :
#   dt_from_unix = try datetime.Datetime.from_unix({s}, datetime.Timeunit.second);
#   dt_from_fields = try datetime.Datetime.from_fields(.{OPEN_BRACE}.year={dt.year}, .month={dt.month}, .day={dt.day}, .hour={dt.hour}, .minute={dt.minute}, .second={dt.second}, .nanosecond=0{CLOSE_BRACE});
#   try std.testing.expect(std.meta.eql(dt_from_unix, dt_from_fields));
# """
#     )
# print("}")

# --- nanoseconds, use narrow range to avoid floating point arithmetic errors ---

UNIX_us_MIN = -2208988800000000  # year 1900
UNIX_us_MAX = 4102444800000000  # year 2100

content.append('test "unix nanoseconds, fields" {\n')
content.append(
    """    var dt_from_unix: Datetime = .{};
    var dt_from_fields: Datetime = .{};
    var unix: i128 = 0;
    """
)

for us in random.sample(range(UNIX_us_MIN, UNIX_us_MAX + 1), 100):
    rnd = random.randint(0, 999)
    dt = datetime.fromtimestamp(us / 1e6, tz=timezone.utc)
    content.append(
        f"""\n  // {dt.isoformat()} :
    dt_from_unix = try Datetime.fromUnix({us*1000+rnd}, Duration.Resolution.nanosecond, null);
    dt_from_fields = try Datetime.fromFields(.{OPEN_BRACE}.year={dt.year}, .month={dt.month}, .day={dt.day}, .hour={dt.hour}, .minute={dt.minute}, .second={dt.second}, .nanosecond={(us % 1_000_000) * 1000+rnd}{CLOSE_BRACE});
    try std.testing.expect(std.meta.eql(dt_from_unix, dt_from_fields));
    unix = dt_from_fields.toUnix(Duration.Resolution.nanosecond);
    try std.testing.expectEqual({us*1000+rnd}, unix);
"""
    )

content.append("}\n")

with open(dst, "w") as fobj:
    fobj.writelines(content)
